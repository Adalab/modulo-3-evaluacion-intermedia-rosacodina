{"ast":null,"code":"import _slicedToArray from\"/Users/Rosa/Desktop/projects ADALAB/Mo\\u0301dulo-3/EVALUACIONES/modulo-3-evaluacion-intermedia-rosacodina/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import'../styles/App.scss';import{useEffect,useState}from'react';// Función principal.\nimport{jsx as _jsx}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";function App(){useEffect(function(){fetch('https://beta.adalab.es/curso-intensivo-fullstack-recursos/apis/quotes-friends-tv-v1/quotes.json').then(function(response){return response.json();}).then(function(data){return setData(data);});//cuando la API responde, guardamos los datos en el estado para que se vuelva a renderizar poniendo setStarWatsData por ejemplo\n});//Variable de estado que contenga las frases\nvar _useState=useState([]),_useState2=_slicedToArray(_useState,2),data=_useState2[0],setData=_useState2[1];//Pintar la lista\nvar phrasesData=data.map(function(phrase){return/*#__PURE__*/_jsx(\"li\",{children:phrase.quote});});//-----------------\n//Cada vez que queramos pintar en el HTML datos que vienen de un listado, array, tenemos que hacer un map\nreturn/*#__PURE__*/ (// Como solo se puede devolver una etiqueta, se puede usar una etiqueta ficticia vacia, llamada FRAGMENTO, y que se escribe, abriendo y cerrando la etiqueta vacia, así \"<> html </>\".\n_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(\"header\",{children:/*#__PURE__*/_jsx(\"h1\",{children:\"Frases de Friends\"})}),/*#__PURE__*/_jsx(\"body\",{children:/*#__PURE__*/_jsx(\"ul\",{children:phrasesData})})]}));}export default App;","map":{"version":3,"sources":["/Users/Rosa/Desktop/projects ADALAB/Módulo-3/EVALUACIONES/modulo-3-evaluacion-intermedia-rosacodina/src/components/App.js"],"names":["useEffect","useState","App","fetch","then","response","json","data","setData","phrasesData","map","phrase","quote"],"mappings":"+LAAA,MAAO,oBAAP,CACA,OAASA,SAAT,CAAoBC,QAApB,KAAoC,OAApC,CAEA;6IACA,QAASC,CAAAA,GAAT,EAAe,CACbF,SAAS,CAAC,UAAM,CACdG,KAAK,CACH,iGADG,CAAL,CAGGC,IAHH,CAGQ,SAACC,QAAD,QAAcA,CAAAA,QAAQ,CAACC,IAAT,EAAd,EAHR,EAIGF,IAJH,CAIQ,SAACG,IAAD,QAAUC,CAAAA,OAAO,CAACD,IAAD,CAAjB,EAJR,EAKA;AACD,CAPQ,CAAT,CASA;AAEA,cAAwBN,QAAQ,CAAC,EAAD,CAAhC,wCAAOM,IAAP,eAAaC,OAAb,eAEA;AACA,GAAMC,CAAAA,WAAW,CAAGF,IAAI,CAACG,GAAL,CAAS,SAACC,MAAD,qBAAY,oBAAKA,MAAM,CAACC,KAAZ,EAAZ,EAAT,CAApB,CAEA;AACA;AAEA,oBACE;AACA,wCACE,qCACE,yCADF,EADF,cAIE,mCACE,oBAAKH,WAAL,EADF,EAJF,GAFF,EAWD,CAED,cAAeP,CAAAA,GAAf","sourcesContent":["import '../styles/App.scss';\nimport { useEffect, useState } from 'react';\n\n// Función principal.\nfunction App() {\n  useEffect(() => {\n    fetch(\n      'https://beta.adalab.es/curso-intensivo-fullstack-recursos/apis/quotes-friends-tv-v1/quotes.json'\n    )\n      .then((response) => response.json())\n      .then((data) => setData(data));\n    //cuando la API responde, guardamos los datos en el estado para que se vuelva a renderizar poniendo setStarWatsData por ejemplo\n  });\n\n  //Variable de estado que contenga las frases\n\n  const [data, setData] = useState([]);\n\n  //Pintar la lista\n  const phrasesData = data.map((phrase) => <li>{phrase.quote}</li>);\n\n  //-----------------\n  //Cada vez que queramos pintar en el HTML datos que vienen de un listado, array, tenemos que hacer un map\n\n  return (\n    // Como solo se puede devolver una etiqueta, se puede usar una etiqueta ficticia vacia, llamada FRAGMENTO, y que se escribe, abriendo y cerrando la etiqueta vacia, así \"<> html </>\".\n    <>\n      <header>\n        <h1>Frases de Friends</h1>\n      </header>\n      <body>\n        <ul>{phrasesData}</ul>\n      </body>\n    </>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}